package com.epicstuff.service;

import com.epicstuff.model.Song;
import com.epicstuff.model.Character;
import com.epicstuff.repository.SongRepository;
import com.epicstuff.repository.CharacterRepository;
import com.epicstuff.dto.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional
public class SongService {

    @Autowired
    private SongRepository songRepository;
    
    @Autowired
    private CharacterRepository characterRepository;

    // // [DONE] Get all songs with filtering
    public Page<Song> findAllWithFilter(SongFilterRequest filter, Pageable pageable) {
        return songRepository.findAllWithFilter(filter, pageable);
    }

    // // [DONE] Get song by ID with populated relationships
    public Optional<Song> findByIdWithRelations(Long id) {
        return songRepository.findByIdWithCharacters(id);
    }

    // // [DONE] Create new song with array validation
    public Song createSong(SongCreateRequest request) {
        // // [DONE] Custom validation beyond annotations
        validateSongRequest(request);
        
        Song song = Song.builder()
            .title(request.getTitle())
            .trackNumber(request.getTrackNumber())
            .description(request.getDescription())
            .durationSeconds(request.getDurationSeconds())
            .sagaId(request.getSagaId())
            
            // // [DONE] Array fields with validation and cleaning
            .themes(validateAndCleanStringList(request.getThemes()))
            .genres(validateAndCleanStringList(request.getGenres()))
            .instruments(validateAndCleanStringList(request.getInstruments()))
            .vocals(validateAndCleanStringList(request.getVocals()))
            .moods(validateAndCleanStringList(request.getMoods()))
            .tags(validateAndCleanStringList(request.getTags()))
            
            // // [DONE] Song structure arrays
            .songSections(validateAndCleanStringList(request.getSongSections()))
            .lyricHighlights(validateAndCleanStringList(request.getLyricHighlights()))
            
            // // [DONE] External reference arrays
            .amazonMusicIds(validateAndCleanStringList(request.getAmazonMusicIds()))
            .youtubeIds(validateAndCleanStringList(request.getYoutubeIds()))
            .inspirationSources(validateAndCleanStringList(request.getInspirationSources()))
            
            // // [DONE] Character relationships
            .characterIds(request.getCharacterIds() != null ? new ArrayList<>(request.getCharacterIds()) : new ArrayList<>())
            
            // // [DONE] Metadata
            .lyricist(request.getLyricist())
            .composer(request.getComposer())
            .producer(request.getProducer())
            .recordingDate(request.getRecordingDate())
            .albumArtUrl(request.getAlbumArtUrl())
            .isInstrumental(request.getIsInstrumental())
            .hasDialogue(request.getHasDialogue())
            .isReprise(request.getIsReprise())
            .originalSongId(request.getOriginalSongId())
            
            .build();
        
        // // [DONE] Validate character IDs exist
        if (request.getCharacterIds() != null && !request.getCharacterIds().isEmpty()) {
            validateCharacterIds(request.getCharacterIds());
        }
        
        return songRepository.save(song);
    }

    // // [DONE] Update existing song
    public Optional<Song> updateSong(Long id, SongUpdateRequest request) {
        return songRepository.findById(id).map(existingSong -> {
            // // [DONE] Update basic fields if provided
            if (request.getTitle() != null) {
                existingSong.setTitle(request.getTitle());
            }
            if (request.getTrackNumber() != null) {
                existingSong.setTrackNumber(request.getTrackNumber());
            }
            if (request.getDescription() != null) {
                existingSong.setDescription(request.getDescription());
            }
            if (request.getDurationSeconds() != null) {
                existingSong.setDurationSeconds(request.getDurationSeconds());
            }
            
            // // [DONE] Update arrays if provided (with validation)
            if (request.getThemes() != null) {
                existingSong.setThemes(validateAndCleanStringList(request.getThemes()));
            }
            if (request.getGenres() != null) {
                existingSong.setGenres(validateAndCleanStringList(request.getGenres()));
            }
            if (request.getInstruments() != null) {
                existingSong.setInstruments(validateAndCleanStringList(request.getInstruments()));
            }
            if (request.getVocals() != null) {
                existingSong.setVocals(validateAndCleanStringList(request.getVocals()));
            }
            if (request.getMoods() != null) {
                existingSong.setMoods(validateAndCleanStringList(request.getMoods()));
            }
            if (request.getTags() != null) {
                existingSong.setTags(validateAndCleanStringList(request.getTags()));
            }
            
            // // [DONE] Update character relationships if provided
            if (request.getCharacterIds() != null) {
                validateCharacterIds(request.getCharacterIds());
                existingSong.setCharacterIds(new ArrayList<>(request.getCharacterIds()));
            }
            
            // // [DONE] Update song structure arrays if provided
            if (request.getSongSections() != null) {
                existingSong.setSongSections(validateAndCleanStringList(request.getSongSections()));
            }
            if (request.getLyricHighlights() != null) {
                existingSong.setLyricHighlights(validateAndCleanStringList(request.getLyricHighlights()));
            }
            
            // // [DONE] Update external reference arrays if provided
            if (request.getAmazonMusicIds() != null) {
                existingSong.setAmazonMusicIds(validateAndCleanStringList(request.getAmazonMusicIds()));
            }
            if (request.getYoutubeIds() != null) {
                existingSong.setYoutubeIds(validateAndCleanStringList(request.getYoutubeIds()));
            }
            if (request.getInspirationSources() != null) {
                existingSong.setInspirationSources(validateAndCleanStringList(request.getInspirationSources()));
            }
            
            // // [DONE] Update metadata if provided
            if (request.getLyricist() != null) {
                existingSong.setLyricist(request.getLyricist());
            }
            if (request.getComposer() != null) {
                existingSong.setComposer(request.getComposer());
            }
            if (request.getProducer() != null) {
                existingSong.setProducer(request.getProducer());
            }
            if (request.getRecordingDate() != null) {
                existingSong.setRecordingDate(request.getRecordingDate());
            }
            if (request.getAlbumArtUrl() != null) {
                existingSong.setAlbumArtUrl(request.getAlbumArtUrl());
            }
            if (request.getIsInstrumental() != null) {
                existingSong.setIsInstrumental(request.getIsInstrumental());
            }
            if (request.getHasDialogue() != null) {
                existingSong.setHasDialogue(request.getHasDialogue());
            }
            if (request.getIsReprise() != null) {
                existingSong.setIsReprise(request.getIsReprise());
            }
            if (request.getOriginalSongId() != null) {
                existingSong.setOriginalSongId(request.getOriginalSongId());
            }
            
            return songRepository.save(existingSong);
        });
    }

    // // [DONE] Delete song
    public boolean deleteSong(Long id) {
        if (songRepository.existsById(id)) {
            songRepository.deleteById(id);
            return true;
        }
        return false;
    }

    // // [DONE] Get song characters
    public List<Character> getSongCharacters(Long id) {
        return songRepository.findById(id)
            .map(song -> characterRepository.findAllById(song.getCharacterIds()))
            .orElse(new ArrayList<>());
    }

    // // [DONE] Add character to song
    public Optional<Song> addCharacterToSong(Long songId, Long characterId) {
        if (!characterRepository.existsById(characterId)) {
            throw new IllegalArgumentException("Character not found: " + characterId);
        }
        
        return songRepository.findById(songId).map(song -> {
            if (!song.getCharacterIds().contains(characterId)) {
                song.getCharacterIds().add(characterId);
                return songRepository.save(song);
            }
            return song;
        });
    }

    // // [DONE] Remove character from song
    public Optional<Song> removeCharacterFromSong(Long songId, Long characterId) {
        return songRepository.findById(songId).map(song -> {
            song.getCharacterIds().remove(characterId);
            return songRepository.save(song);
        });
    }

    // // [DONE] Find songs by character
    public List<Song> findSongsByCharacter(Long characterId) {
        return songRepository.findByCharacterIdsContaining(characterId);
    }

    // // [DONE] Find songs by saga
    public List<Song> findSongsBySaga(Long sagaId) {
        return songRepository.findBySagaIdOrderByTrackNumber(sagaId);
    }

    // // [DONE] Get song statistics
    public Optional<SongStatsResponse> getSongStats(Long id) {
        return songRepository.findByIdWithCharacters(id).map(song -> {
            return SongStatsResponse.builder()
                .songId(song.getId())
                .songTitle(song.getTitle())
                .durationSeconds(song.getDurationSeconds())
                .characterCount(song.getCharacterIds().size())
                
                // Array statistics
                .allThemes(song.getThemes())
                .allGenres(song.getGenres())
                .allInstruments(song.getInstruments())
                .allVocals(song.getVocals())
                .allMoods(song.getMoods())
                .allTags(song.getTags())
                .themeCount(countStringOccurrences(song.getThemes()))
                .genreCount(countStringOccurrences(song.getGenres()))
                .moodCount(countStringOccurrences(song.getMoods()))
                
                // Character statistics
                .characterNames(getCharacterNames(song.getCharacterIds()))
                .characterTypeCount(getCharacterTypeCount(song.getCharacterIds()))
                
                // Structure statistics
                .sectionCount(song.getSongSections().size())
                .lyricHighlightCount(song.getLyricHighlights().size())
                .externalLinkCount(song.getAmazonMusicIds().size() + song.getYoutubeIds().size())
                .inspirationSourceCount(song.getInspirationSources().size())
                
                // Musical metadata
                .isInstrumental(song.getIsInstrumental())
                .hasDialogue(song.getHasDialogue())
                .isReprise(song.getIsReprise())
                .originalSongTitle(getOriginalSongTitle(song.getOriginalSongId()))
                
                .build();
        });
    }

    // // [DONE] Private validation methods
    private void validateSongRequest(SongCreateRequest request) {
        // // [DONE] Validate themes aren't duplicates
        if (hasDuplicates(request.getThemes())) {
            throw new IllegalArgumentException("Themes cannot contain duplicates");
        }
        
        // // [DONE] Validate genres aren't duplicates
        if (hasDuplicates(request.getGenres())) {
            throw new IllegalArgumentException("Genres cannot contain duplicates");
        }
        
        // // [DONE] Validate predefined theme/genre lists
        validateAgainstAllowedValues(request.getThemes(), getAllowedThemes(), "theme");
        validateAgainstAllowedValues(request.getGenres(), getAllowedGenres(), "genre");
        validateAgainstAllowedValues(request.getInstruments(), getAllowedInstruments(), "instrument");
        validateAgainstAllowedValues(request.getVocals(), getAllowedVocals(), "vocal");
        validateAgainstAllowedValues(request.getMoods(), getAllowedMoods(), "mood");
        
        // // [DONE] Validate reprise logic
        if (Boolean.TRUE.equals(request.getIsReprise()) && request.getOriginalSongId() == null) {
            throw new IllegalArgumentException("Reprise songs must reference an original song");
        }
    }

    private List<String> validateAndCleanStringList(List<String> strings) {
        if (strings == null) return new ArrayList<>();
        
        return strings.stream()
            .filter(Objects::nonNull)
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .distinct() // Remove duplicates
            .collect(Collectors.toList());
    }

    private boolean hasDuplicates(List<String> list) {
        if (list == null) return false;
        Set<String> seen = new HashSet<>();
        return list.stream().anyMatch(item -> !seen.add(item.toLowerCase().trim()));
    }

    private void validateAgainstAllowedValues(List<String> values, Set<String> allowedValues, String fieldName) {
        if (values == null || allowedValues == null) return;
        
        List<String> invalid = values.stream()
            .filter(value -> !allowedValues.contains(value.toLowerCase().trim()))
            .collect(Collectors.toList());
        
        if (!invalid.isEmpty()) {
            throw new IllegalArgumentException(
                String.format("Invalid %s values: %s. Allowed values: %s", 
                    fieldName, invalid, allowedValues)
            );
        }
    }

    private void validateCharacterIds(List<Long> characterIds) {
        List<Long> existingIds = characterRepository.findAllById(characterIds)
            .stream()
            .map(Character::getId)
            .collect(Collectors.toList());
        
        List<Long> invalidIds = characterIds.stream()
            .filter(id -> !existingIds.contains(id))
            .collect(Collectors.toList());
        
        if (!invalidIds.isEmpty()) {
            throw new IllegalArgumentException("Invalid character IDs: " + invalidIds);
        }
    }

    // // [DONE] Predefined allowed values for Epic Timeline
    private Set<String> getAllowedThemes() {
        return Set.of(
            "heroism", "journey", "family", "perseverance", "redemption", "war", 
            "homecoming", "wisdom", "sacrifice", "divine intervention", "love", 
            "betrayal", "transformation", "destiny", "honor", "temptation", "growth"
        );
    }

    private Set<String> getAllowedGenres() {
        return Set.of(
            "rock opera", "ballad", "dramatic", "epic", "folk", "orchestral", 
            "electronic", "classical", "battle", "emotional", "narrative", "ensemble"
        );
    }

    private Set<String> getAllowedInstruments() {
        return Set.of(
            "electric guitar", "acoustic guitar", "bass", "drums", "piano", "strings", 
            "brass", "woodwinds", "synthesizer", "harp", "lyre", "percussion", 
            "voice", "choir", "orchestra", "rock band"
        );
    }

    private Set<String> getAllowedVocals() {
        return Set.of(
            "male lead", "female lead", "baritone", "tenor", "bass", "soprano", 
            "alto", "mezzo-soprano", "chorus", "ensemble", "spoken", "rap", "chant"
        );
    }

    private Set<String> getAllowedMoods() {
        return Set.of(
            "triumphant", "melancholic", "energetic", "peaceful", "tense", "mysterious", 
            "romantic", "heroic", "dark", "hopeful", "epic", "intimate", "dramatic"
        );
    }

    // // [DONE] Helper methods for statistics
    private Map<String, Integer> countStringOccurrences(List<String> strings) {
        return strings.stream()
            .collect(Collectors.groupingBy(
                String::toLowerCase, 
                Collectors.collectingAndThen(Collectors.counting(), Math::toIntExact)
            ));
    }

    private List<String> getCharacterNames(List<Long> characterIds) {
        return characterRepository.findAllById(characterIds)
            .stream()
            .map(Character::getName)
            .collect(Collectors.toList());
    }

    private Map<String, Integer> getCharacterTypeCount(List<Long> characterIds) {
        return characterRepository.findAllById(characterIds)
            .stream()
            .collect(Collectors.groupingBy(
                character -> character.getCharacterType().toString(),
                Collectors.collectingAndThen(Collectors.counting(), Math::toIntExact)
            ));
    }

    private String getOriginalSongTitle(Long originalSongId) {
        if (originalSongId == null) return null;
        return songRepository.findById(originalSongId)
            .map(Song::getTitle)
            .orElse(null);
    }
}
